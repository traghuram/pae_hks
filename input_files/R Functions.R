

# R Functions -------------------------------------------------------------
# rm(list=ls())
# source("/Users/DanielYudkin/Dropbox/R/R Functions.R")
# Read and write files.

library(pacman)
p_load(tidyverse,
       sjPlot,
       sjstats,
       corrplot,
       psych,
       lme4,
       readxl,
       tools,
       lavaan,
       ggrepel,
       RColorBrewer,
       lmerTest,
       mice,
       emmeans,
       janitor)
       
       


# RIO IMPORT
summarize <- dplyr::summarize
select <- dplyr::select
# Read.csv

# my.read <- function(x){
#                 read.csv(x, stringsAsFactors = F)
#
# }

my.read <- function(x, ...) {
        if (file_ext(x) == "csv") {
                read.csv(x, stringsAsFactors = F)
        }
        else
                (read_excel(x))
}
# qualtrics_api_credentials("TAlX741tIQoLNhwBdFZEQaGbf2PWYTWTv8fTKVcZ", "upenn.co1.qualtrics.com", install = T,
#                           overwrite = T)
# 


# Clear -------------------------------------------------------------------
clear <- function(x){
        rm(list = ls(envir = .GlobalEnv), envir = .GlobalEnv)
}


# Import Qualtrics. 
import_study <- function(study_name, label = F, ...){
        require("qualtRics")
        filename <- study_name
        surveys <- all_surveys()
        id <- surveys[surveys$name==filename,]$id
        data <- fetch_survey(surveyID = id,
                             convert = F,
                             label = label,
                             force_request = T,
                             ...)
        data <- data %>% arrange(StartDate) %>% 
                mutate(ID = row_number()) %>% select(ID, everything())
        return(data %>% tibble())
}


my.extract.labels <- function(dataframe){
        labels_list <- map_chr(dataframe, 
                               function(x) attr(x, "label")) %>% 
                str_split(" - ") %>% # Turns into a list of lists
                sapply("[[", 2)   # Get the second sub-element of every list
        names(dataframe) <- labels_list
        return(dataframe)
}


# Write csv.
my.write <- function(x, y, row.names = F) {
        write.csv(x, y, row.names = row.names)
        
}

# Save plot and table.
my.save.graph <-
        function(summary.table.name,
                 summary.filename,
                 graph.name,
                 graph.filename) {
                my.write(summary.table.name, summary.filename)
                
                pdf(graph.filename, width = 12, height = 8)
                print(graph.name)
                dev.off()
                
        }

my.save.graph.2 <-
        function(outputvariable,
                 table.filename,
                 graph.filename) {
                my.write(outputvariable[[1]], table.filename)
                pdf(graph.filename, width = 12, height = 8)
                print(outputvariable[[2]])
                dev.off()
                
        }


# Mean and sd
my.stats <- function(x) {
        mean = mean(x, na.rm = T)
        sd = sd(x, na.rm = T)
        n = sum(!is.na(x))
        print <-
                paste0(paste0("Mean: ", mean, "; "),
                  paste0("SD: ", sd, "; "),
                  paste0("N: ", n, "; "))
        return(print)
        
}

my.see.last.columns <- function(data, n = 30) {
        head(data[, (ncol(data) - n):ncol(data)], n)
}

my.outersect <- function(x, y) {
        list(setdiff(x, y),
               setdiff(y, x))
}

my.table <- function(...){
        x <- table(..., useNA = "always")
        return(x)
        
}

# Graphs ------------------------------------------------------------------



# Colors ------------------------------------------------------------------


my.blue <- "#1675B5"
my.red <- "#b52616"
red.blue <- c("#1675B5", "#b52616")
my.bright.colors <- c("#0011ff", "#ff0000")
blue.yellow <- c("#0273C2", "#EFC10F")




my.graph.settings <- function(angle = 0, size = 12) {
        my.graph.settings <-
                theme_bw(base_size = size) +
                theme(
                        panel.border = element_blank(),
                        axis.line = element_line(colour = "black"),
                        panel.grid.major.x = element_blank(),
                        panel.grid.minor.x = element_blank(),
                        panel.grid.minor.y = element_blank(),
                        panel.background = element_rect(fill = "transparent", colour = NA),
                        plot.background = element_rect(fill = "transparent", colour = NA),
                        legend.key = element_rect(fill = "transparent", colour = NA),
                        legend.background = element_rect(fill = "transparent", colour = NA),
                        axis.text =  element_text(colour = "black"),
                        axis.title = element_text(face = "bold"),
                        plot.title = element_text(hjust = 0.5)
                )
        if (angle > 0) {
                my.graph.settings <-
                        my.graph.settings +
                        theme(axis.text.x = element_text(angle = angle, hjust = 1))
        }
        return(my.graph.settings)
}



# SummarySE ---------------------------------------------------------------

my.summary <-
        function(dataset,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                condensed <- dataset %>% group_by(!!quo_x) %>%
                        summarise(
                                sd = sd(!!quo_y, na.rm = T),
                                se = sd / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                n = sum(!is.na(!!quo_y))
                        ) %>%
                        mutate(
                                min = mean - qt(.975, n - 1) * se,
                                lower = mean - se,
                                upper = mean + se,
                                max = mean + qt(.975, n - 1) * se
                        )
                return(condensed)
        }




my.grouped.summary <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                condensed <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                sd = sd(!!quo_y, na.rm = T),
                                SE = sd / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y),
                                n = n()
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                return(condensed)
        }

my.grouped.grouped.summary <-
        function(dataset,
                 x,
                 y,
                 group1,
                 group2,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group1 <- sym(group1)
                quo_group2 <- sym(group2)
                condensed <- dataset %>% group_by(!!quo_group1, !!quo_group2, !!quo_x) %>%
                        summarise(
                                sd = sd(!!quo_y, na.rm = T),
                                SE = sd / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y),
                                n = n()
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                return(condensed)
        }



# Transpose ---------------------------------------------------------------

my.transpose <- function(data.frame, row.name) {
        # first remember the names
        n <- data.frame[[row.name]]
        # transpose all but the first column (name)
        data.frame <- as.data.frame(t(data.frame[, ]))
        colnames(data.frame) <- n
        return(data.frame)
}

my.center <- function(x) {
        x <- x - mean(x, na.rm = T)
        x
}


my.scale <- function(x) {
        x <- x - mean(x, na.rm = T)
        x <- x / sd(x, na.rm = T)
        return(x)
}

my.reorder <- function(dataframe, factor, orderVar) {
        quo_factor <- sym(factor)
        quo_orderVar <- sym(orderVar)
        dataframe <- dataframe %>%
                arrange(!!quo_orderVar) %>%
                mutate(factor = factor(!!quo_factor,!!quo_factor))
        dataframe

}



my.table.output <- function(table, rhs, lhs) {
        row <- table[table$lhs == lhs & table$rhs == rhs, ]
        beta <- round(row[3], 3)
        SE <- round(row[4], 3)
        p <- round(row[5], 3)
        output <-
                ifelse(
                        p >= .001,
                        paste0("_B_", " = ", beta, ", _SE_", " = ", SE, ", _p_ = ", p),
                        ifelse(
                                p < .001,
                                paste0("_B_", " = ", beta, ", _SE_", " = ", SE, ", _p_ < ", .001),
                                NA
                        )
                )
        return(output)
}



# Regression Output -------------------------------------------------------
my.lm <- function(data,
                          predictor,
                          dv,
                          controls,
                          row.name = predictor,
                          add.controls = NULL,
                          rm.controls = NULL,
                          caption = NULL,
                  type = "summary") {
        model <-
                my.return.model.lm(data,
                                   predictor,
                                   dv,
                                   controls,
                                   add.controls,
                                   rm.controls)
        if (Console == T) {
                if (type == "summary"){
                        print(summary(model))
                        print(my.lm.output((model), row.name))
                }
                else if (type == "anova"){
                        print(anova(model))
                        print(my.lm.output((model), row.name))
                }
        }
        if (PDF == T) {
                print_lm(model, predictor, dv, caption)
        }
        return(model)
        
}
my.regress.lm <- my.lm


my.lmer <- function(data,
                            predictor,
                            dv,
                            controls,
                            rdm.effect,
                            row.name = predictor,
                            add.controls = NULL,
                            rm.controls = NULL,
                            caption = NULL) {
        model <-
                my.return.model.lmer(data,
                                   predictor,
                                   dv,
                                   controls,
                                   rdm.effect,
                                   add.controls,
                                   rm.controls)
        if (Console == T) {
                print(summary(model))
                print(my.lmer.output((model), row.name))
        }
        if (PDF == T) {
                print(print_lmer(model, predictor, dv, caption))
        }
        invisible(model)
}


my.return.model.lm <- function(data, predictor, dv, controls, add.controls = NULL, rm.controls = NULL) {
        controls <- controls[!controls %in% rm.controls]
        controls <- paste(c(controls, add.controls), collapse = " + ")
        predictors <- paste(predictor, controls, sep = " + ")
        formula <- paste(dv, predictors, sep = " ~ ")
        model <- lm(formula, data = data)
        return(model)
}

my.return.model.lmer <- function(data, predictor, dv, controls, rdm.effect, add.controls = NULL, rm.controls = NULL) {
        controls <- controls[!controls %in% rm.controls]
        controls <- paste(c(controls, add.controls), collapse = " + ")
        rdm.effect <- paste0("(1|", rdm.effect, ")")
        predictors <-
                paste(predictor, controls, rdm.effect, sep = " + ")
        formula <- paste(dv, predictors, sep = " ~ ")
        model <- lmer(formula, data = data)
        return(model)
}




my.lm.output <- function(model, variable) {
        coefs <- filter(tidy(model), term == variable)
        beta <- sprintf("%.2f", round(coefs$estimate, 2))
        SE <- sprintf("%.2f", round(coefs$std.error, 2))
        t <- sprintf("%.2f", round(coefs$statistic, 2))
        df <- glance(model)$df.residual %>% round()
        p <- round(coefs$p.value, 3)
        output2 <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _t_(",
                                df,
                                ") = ",
                                t,
                                ", _p_ = ",
                                p
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _t_(",
                                        df,
                                        ") = ",
                                        t,
                                        ", _p_ < ",
                                        .001
                                ),
                                NA
                        )
                )
        output <- as.vector(output2)
        print(summary(model))
        return(output)
}



my.lmer.output <- function(model, variable) {
        model <- as_lmerModLmerTest(model)
        print(summary(model))
        coefs <- summary(model)$coefficients[variable, ]
        beta <- sprintf("%.2f", round(coefs[1], 2))
        SE <- sprintf("%.2f", round(coefs[2], 2))
        t <- sprintf("%.2f", round(coefs[4], 2))
        df <- round(coefs[3], 0)
        p <- round(coefs[5], 3)
        output <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _t_(",
                                df,
                                ") = ",
                                t,
                                ", _p_ = ",
                                p
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _t_(",
                                        df,
                                        ") = ",
                                        t,
                                        ", _p_ < ",
                                        .001
                                ),
                                NA
                        )
                )
        output <- as.vector(output)
        return(output)
}



my.glmer.output <- function(model, variable) {
        print(summary(model))
        coefs <- summary(model)$coefficients[variable, ]
        beta <- sprintf("%.2f", round(coefs[1], 2))
        SE <- sprintf("%.2f", round(coefs[2], 2))
        z <- sprintf("%.2f", round(coefs[3], 2))
        p <- round(coefs[4], 3)
        output <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _z_ = ",
                                z,
                                ", _p_ = ",
                                p
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _z_ = ",
                                        z,
                                        ", _p_ < ",
                                        .001
                                ),
                                NA
                        )
                )
        output <- as.vector(output)
        return(output)
}

my.anova <- function(model, variable = NULL, md = T){
        print(anova(model))
        if(class(model) != "lm") {
                anova1 <- anova(model)
                if (is.null(variable)){
                        row = anova1[1,]
                } else {
                        row = anova1[rownames(anova1) == variable,]
                }
                numerator <- round(row$NumDF, 0)
                denomonator <- round(row$DenDF, 0)
                f.value <- sprintf("%.2f", row$`F value` %>% round(., 2))
                p.value <- row$`Pr(>F)`
                p.round <- round(p.value, 3)
                p.string <- ifelse(p.value > .001, paste0("_p_ = ", p.round),
                                   "_p_ < .001")
                output <- paste0("_F_", 
                                 "(",
                                 numerator, 
                                 ", ",
                                 denomonator,
                                 ") = ",
                                 f.value,
                                 ", ",
                                 p.string)
                print(list(anova1, output))
        }
        else if(class(model) == "lm"){
                
                anova1 <- anova(model)
                if (is.null(variable)){
                        row = anova1[1,]
                } else {
                        row = anova1[rownames(anova1) == variable,]
                }
                numerator <- round(row$Df, 0)
                denomonator <- round(tail(anova1$Df, 1), 0)
                f.value <- sprintf("%.2f", row$`F value` %>% round(., 2))
                p.value <- row$`Pr(>F)`
                p.round <- round(p.value, 3)
                p.string <- ifelse(p.value > .001, paste0("_p_ = ", p.round),
                                   "_p_ < .001")
                output <- paste0("_F_", 
                                 "(",
                                 numerator, 
                                 ", ",
                                 denomonator,
                                 ") = ",
                                 f.value,
                                 ", ",
                                 p.string)
                if (md == F){
                        print(list(anova1, output))
                }
                else {
                        return(output)
                }
        }
}



my.anova <- function(model, variable = NULL, md = T){
        if(class(model) != "lm") {
                anova1 <- anova(model)
                if (is.null(variable)){
                  row = anova1[1,]
                } else {
                  row = anova1[rownames(anova1) == variable,]
                }
                numerator <- round(row$NumDF, 0)
                denomonator <- round(row$DenDF, 0)
                f.value <- sprintf("%.2f", row$`F value` %>% round(., 2))
                p.value <- row$`Pr(>F)`
                p.round <- round(p.value, 3)
                p.string <- ifelse(p.value > .001, paste0("_p_ = ", p.round),
                                                          "_p_ < .001")
                output <- paste0("_F_",
                                 "(",
                                 numerator,
                                 ", ",
                                 denomonator,
                                 ") = ",
                                 f.value,
                                 ", ",
                                 p.string)
        }
        else if(class(model) == "lm"){

        anova1 <- anova(model)
        if (is.null(variable)){
                row = anova1[1,]
        } else {
                row = anova1[rownames(anova1) == variable,]
        }
        numerator <- round(row$Df, 0)
        denomonator <- round(tail(anova1$Df, 1), 0)
        f.value <- sprintf("%.2f", row$`F value` %>% round(., 2))
        p.value <- row$`Pr(>F)`
        p.round <- sprintf("%.3f", round(p.value, 3))
        p.string <- ifelse(p.value > .001, paste0("_p_ = ", p.round),
                           "_p_ < .001")
        output <- paste0("_F_",
                         "(",
                         numerator,
                         ", ",
                         denomonator,
                         ") = ",
                         f.value,
                         ", ",
                         p.string)
        }
        cohens_f <- effectsize::cohens_f(anova1, ci = 0.95)
        f_select <- cohens_f %>% filter(Parameter==variable)
        f_output <- paste0(c("__f__ = ",
                             sprintf("%.2f", round(f_select$Cohens_f, 2)),
                             ", CI#95#[",
                             sprintf("%.2f", round(f_select$CI_low, 2)),
                             ", ",
                             sprintf("%.2f", round(f_select$CI_high, 2)),
                             "]"), collapse = "")
        output <- paste(output, f_output, sep = ", ")
        print(list(anova1, output))

        # Get emmeans
        means <- emmeans(model, variable) %>% summary()
        mean_1 <- paste0(c(as.character(means[variable][1,]),
                           "(_M_ = ",
                           sprintf("%.2f", round(means$emmean[1], 2)),
                           ", _SD_ = ",
                           sprintf("%.2f", round(means$SE[1]*sqrt(nobs(model)), 2)),
                           ")"),
                         collapse = "")

        mean_2 <- paste0(c(as.character(means[variable][2,]),
                           "(_M_ = ",
                           sprintf("%.2f", round(means$emmean[2], 2)),
                           ", _SD_ = ",
                           sprintf("%.2f", round(means$SE[2]*sqrt(nobs(model)), 2)),
                           ")"),
                         collapse = "")
        print(list(mean_1, mean_2))
}

# Residuals ---------------------------------------------------------------



my.lm.resid <- function(data, DV, controls) {
        controls <- paste(controls, sep = " + ")
        formula <- paste(DV, controls, sep = " ~ ")
        DV.resid <- paste(DV, ".resid", sep = "")
        data <- augment(lm(formula, data = data), data)
        data <-
                data %>% rename_(.dots = setNames(list(".resid"), DV.resid))
        return(data)
}


my.lmer.resid <- function(data, predictor, DV, controls) {
        controls <- paste(controls, sep = " + ")
        formula <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(lm(f, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        return(data)
}





#  Mediation --------------------------------------------------------------
my.compile.lavaan <- function(data, a, b, c, controls = NULL, rm.controls = NULL, title = NULL){
        if(!is.null(controls)){
        equation1 <- paste0(b, " ~ a*", a, " + ", paste(controls, collapse = " + "), "\n")
        equation2 <- paste0(c, " ~ b*", b, " + ", "c*", a, "+", paste(controls, collapse = " + "), "\n")
        equation3 <- "
        IndirectTotal := a*b
        DirectEffect := c
        TotalEffect := c + a*b
        "
        }
        else{
                equation1 <- paste0(b, " ~ a*", a,"\n")
                equation2 <- paste0(c, " ~ b*", b, " + ", "c*", a, "\n")
                equation3 <- "
        IndirectTotal := a*b
        DirectEffect := c
        TotalEffect := c + a*b
        "
        }
        
        model <- paste0(equation1, equation2, equation3)
        model <- cfa(model, data = data, missing = "fiml", std.lv = T)
        
        if (Console == T) {
                output <- summary(model, ci = T)
                table <- standardizedsolution(model)
                indirect.effect <- my.print.indirect.effect(table)
                print(indirect.effect)
                print(table)
        }
        if (PDF == T) {
                print_lavaan(model, title)
        }

        invisible(model)
        
}

my.mediation.simple <- my.compile.lavaan


# Notes:
# a1: a to b
# a2: a to c
# b1: b to c
# b2: b do d
# c: c to d 

my.compile.lavaan.complex <- function(data, a, b, c, d, controls = NULL, rm.controls = NULL, title = NULL){
        controls <- controls[!controls %in% rm.controls]
        equation1 <- paste0(b, " ~ a1*", a, " + ", paste(controls, collapse = " + "), "\n")
        equation2 <- paste0(c, " ~ a2*", a, " + ", "b1*", b, "+", paste(controls, collapse = " + "), "\n")
        equation3 <- paste0(d, " ~ b2*", b, " + ", "c*", c, "+", "d*", a, "+", paste(controls, collapse = " + "), "\n")
        equation4 <- "
        IndirectEffect1 := a1*b1
        IndirectEffect2 := a1*b2
        IndirectEffect3 := a2*c
        IndirectEffect4 := b1*c
        IndirectTotal := a1*b1*c
        DirectEffect := d
        TotalEffect := a1*b1 + a1*b2 + a2*c + b1*c + a1*b1*c + d
        "
        model <- paste0(equation1, equation2, equation3, equation4)
        model <- cfa(model, data = data, missing = "fiml", std.lv = T)
        

        if (Console == T) {
                output <- summary(model, ci = T)
                table <- standardizedsolution(model)
                indirect.effect <- my.print.indirect.effect(table)
                print(indirect.effect)
                
        }
        if (PDF == T) {
                print_lavaan(model, title)
        }
        
        invisible(model)
}
my.mediation.complex <- my.compile.lavaan.complex



my.print.indirect.effect <- function(x){
        beta <- x[x[["lhs"]]=="IndirectTotal",]$est.std %>% round(3)
        SE <- x[x[["lhs"]]=="IndirectTotal",]$se %>% round(3)
        p <- x[x[["lhs"]]=="IndirectTotal",]$pvalue %>% round(3)
        lower <- x[x[["lhs"]]=="IndirectTotal",]$ci.lower %>% round(3)
        upper <- x[x[["lhs"]]=="IndirectTotal",]$ci.upper %>% round(3)
        output <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _p_ = ",
                                p,
                                ", ",
                                "CI_95_[",
                                lower,
                                ", ",
                                upper,
                                "]"
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _p_ < ",
                                        .001,
                                        ", ",
                                        "CI_95_[",
                                        lower,
                                        ", ",
                                        upper,
                                        "]"
                                ),
                                NA
                        )
                )
        return(output)
}








# T-tests -----------------------------------------------------------------
# Single-sample t-test, compare to 0.
my.single.t <- function(x, mu = 0, md = T){
        t <- t.test(x, mu = mu)
        sd <- sd(x, na.rm = T)
        d <- abs(t$estimate - mu) / sd
        if (md == F) {
                print(t)
                print(paste0("SD: ", sd))
                print(paste0("D: ", d))
        }
        if (t$p.value < .001) {
        return(paste0("_t_(", 
                      t$parameter, 
                      ") = ", 
                      round(t$statistic, 2), 
                      ", _p_ < .001", 
                      ", **d** = ", 
                      round(d, 2)))
        }
        else {
        return(paste0("_t_(", 
                      t$parameter, 
                      ") = ", 
                      round(t$statistic, 2), 
                      ", _p_ = ", 
                      round(t$p.value, 3), 
                      ", **d** = ", 
                      round(d, 2)))
        }
}

# Paired Sample t-test
my.paired.t <- function(x, y) {
        t <- t.test(x, y, paired = T)
        sd <- sd(x - y, na.rm = T)
        d <- t$estimate / sd
        mean1 <- mean(x, na.rm = T)
        mean2 <- mean(y, na.rm = T)
        print(t)
        print(paste0("Mean 1: ", mean1, ";  Mean 2: ", mean2))
        print(paste0("SD: ", sd))
        print(paste0("D: ", d))
}


# Independent samples t-test
my.two.sample.t <- function(x, y, md = F) {
        t <- t.test(x ~ y, var.equal = F)
        sd <- sd(x, na.rm = T)
        d <- ((t$estimate[1] - t$estimate[2]) / sd)
        d <-  sprintf("%.2f", round(d, 2))
        if(t$p.value < .001){
                output <- paste0("_t_(", round(t$parameter, 0), ") = ", round(t$statistic, 2), ", _p_ < .001", ", **d** = ", d)
        }
        else{
                output <- paste0("_t_(", round(t$parameter, 0), ") = ", round(t$statistic, 2), ", _p_ = ", round(t$p.value, 3), 
                                 ", **d** = ", d)
        }
        
        if (md == F){
                print(describeBy(x, group = y)[1])
                print(describeBy(x, group = y)[2])
                print(paste0("D: ", d))
                print(t)
                print(output)
        }
        else{
                return(output)
        }
}

my.compare.means <- function(x, y, md = T) {
        t <- t.test(x, y)
        sd <- sd(x, na.rm = T)
        d <- ((t$estimate[1] - t$estimate[2]) / sd) %>% round(2)
        if(t$p.value < .001){
                output <- paste0("_t_(", round(t$parameter, 0), ") = ", round(t$statistic, 2), ", _p_ < .001", ", **d** = ", d)
        }
        else{
                output <- paste0("_t_(", round(t$parameter, 0), ") = ", round(t$statistic, 2), ", _p_ = ", round(t$p.value, 3), ", **d** = ", d)
        }
        
        if (md == F){
                print(describeBy(x, group = y)[1])
                print(describeBy(x, group = y)[2])
                print(paste0("D: ", d))
                print(t)
                print(output)
        }
        else{
                return(output)
        }
}


my.two.sample.t.d <- function(x, y) {
        t <- t.test(x ~ y, var.equal = T)
        sd <- sd(x, na.rm = T)
        d <- (t$estimate[1] - t$estimate[2]) / sd
        return(d)
        
}


# Correlation -------------------------------------------------------------
# Correlation Table, output to current wd
my.correlation.table <-
        function(x,
                 filename,
                 pointsize = 18,
                 r = FALSE,
                 height = 2000,
                 width = 2000,
                 cutoff = .05,
                 order = "FPC") {
                Correlations <- corr.test(x, adjust = "none")
                Correlations$r[is.na(Correlations$r)] <- 0
                Correlations$r[is.infinite(Correlations$r)] <- 1
                Correlations$p[Correlations$p > cutoff] <- NaN
                if (r == FALSE) {
                        png(
                                file = filename,
                                height = height,
                                width = width,
                                pointsize = pointsize
                        )
                        corrplot(
                                Correlations$r,
                                type = "lower",
                                method = "circle",
                                p.mat = Correlations$r,
                                addCoef.col = "black",
                                sig.level = cutoff,
                                insig = "p-value",
                                na.label = "  ",
                                tl.cex = 1,
                                tl.srt = 45,
                                tl.col = "black",
                                order = order 
                        )
                        dev.off()
                }
                if (r == TRUE) {
                        Correlations$r[is.nan(Correlations$p)] <- NaN
                        png(
                                file = filename,
                                height = height,
                                width = width,
                                pointsize = pointsize
                        )
                        corrplot(
                                Correlations$r,
                                type = "lower",
                                method = "circle",
                                sig.level = cutoff,
                                na.label = "  ",
                                tl.cex = 1,
                                tl.srt = 45,
                                tl.col = "black",
                                addCoef.col = "black",
                        )
                        dev.off()
                }
        }


my.correlation.output <- function(dataframe, variable1, variable2) {
        cor <- cor.test(dataframe[[variable1]], dataframe[[variable2]])
        asterisk <- ifelse(cor$p.value > .1, "",
                           ifelse(
                                   between(cor$p.value, .05, .1),
                                   "*",
                                   ifelse(
                                           between(cor$p.value, .01, .05),
                                           "**",
                                           ifelse(cor$p.value < .01, "***", "")
                                   )
                           ))
        output <- paste0(round(cor$estimate, 2), asterisk)
        print(cor$estimate)
        print(cor$p.value)
        return(output)
        
        
}

# Compare Correlation Coefficients
cor.diff.test = function(x1, x2, y1, y2, method = "pearson") {
        cor1 = cor.test(x1, x2, method = method)
        cor2 = cor.test(y1, y2, method = method)
        
        r1 = cor1$estimate
        r2 = cor2$estimate
        n1 = sum(complete.cases(x1, x2))
        n2 = sum(complete.cases(y1, y2))
        fisher = ((0.5 * log((1 + r1) / (1 - r1))) - (0.5 * log((1 + r2) /
                                                                        (1 - r2)))) / ((1 / (n1 - 3)) + (1 / (n2 - 3))) ^ 0.5
        
        p.value = (2 * (1 - pnorm(abs(fisher))))
        
        result = list(
                "cor1" = list(
                        "estimate" = as.numeric(cor1$estimate),
                        "p.value" = cor1$p.value,
                        "n" = n1
                ),
                "cor2" = list(
                        "estimate" = as.numeric(cor2$estimate),
                        "p.value" = cor2$p.value,
                        "n" = n2
                ),
                "p.value.twosided" = as.numeric(p.value),
                "p.value.onesided" = as.numeric(p.value) / 2
        )
        cat(
                paste(
                        sep = "",
                        "cor1: r=",
                        format(result$cor1$estimate, digits = 3),
                        ", p=",
                        format(result$cor1$p.value, digits = 3),
                        ", n=",
                        result$cor1$n,
                        "\n",
                        "cor2: r=",
                        format(result$cor2$estimate, digits = 3),
                        ", p=",
                        format(result$cor2$p.value, digits = 3),
                        ", n=",
                        result$cor2$n,
                        "\n",
                        "diffence: p(one-sided)=",
                        format(result$p.value.onesided, digits = 3),
                        ", p(two-sided)=",
                        format(result$p.value.twosided, digits = 3),
                        "\n"
                )
        )
        return(result)
        
}


# Barplots ----------------------------------------------------------------
my.barplot <-
        function(dataset,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 round = 2,
                 ordered = F,
                 fill = "steelblue",
                 width = .7,
                 angle = 0,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                summary <- my.summary(dataset, x, y)
                summary$mean.R <- round(summary$mean, round)
                summary <- summary[complete.cases(summary), ]
                if(ordered == T){
                        summary <- summary %>% arrange(mean)
                        summary[[x]] <- factor(summary[[x]], levels = summary[[x]])
                }
                print(summary)
                print(quo_x)
                limits <- aes(ymax = summary$max, ymin = summary$min)
                dodge <- position_dodge()
                graph <- ggplot(summary, aes_string(x = x, y = "mean", group = x)) +
                        geom_bar(stat = 'identity',
                                 position = dodge,
                                 fill = fill,
                                 width = width) +
                        # scale_fill_manual(values = c("steelblue",
                        #                              "steelblue",
                        #                              "steelblue",
                        #                              "steelblue",
                        #                              "steelblue",
                        #                              "red"
                        # )) +
                        geom_errorbar(limits, position = dodge, width = 0.1) +
                        # geom_label(aes_string(label = paste0( "n =",  "n")),
                        #            fill = "white",
                        #            position = dodge, 
                        #            size = 2) +
                        my.graph.settings(angle) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(ylim = c((
                                min(summary$lower) - 6 * mean(summary$se)
                        ), (
                                max(summary$upper) + 6 * mean(summary$se)
                        ))) +
                        scale_y_continuous(expand = c(0, 0))
                graph <- graph +
                        annotate("text", x = -Inf, y = Inf, hjust = 0, vjust = 1, label = " Note: errors 95% CI", fontface = 'italic')
                measurevar <- y
                groupvars  <- c(x)
                f <- paste(measurevar, groupvars, sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }

#2 x 2 Bar Graph
my.grouped.barplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 fill.label = group,
                 round = 2,
                 angle = 0,
                 ordered = F,
                 ordered.level = 1) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% my.grouped.summary(x, y, group)
                print(summary)
                if(ordered == T){
                        summary <- summary %>% arrange(mean)
                        summary[[x]] <- factor(summary[[x]], levels = summary[[x]][summary[[group]]==summary[[group]][ordered.level]])
                }
                limits <- aes(ymax = max, ymin = min)
                dodge <- position_dodge(width = .9)
                graph <-
                        ggplot(summary,
                               aes_string(
                                       x = x,
                                       y = "mean",
                                       fill = group,
                                       group = group
                               )) +
                        geom_bar(stat = 'identity', position = dodge) +
                        geom_errorbar(limits, position = dodge, width = .2) +
                        #geom_label(aes_string(label = "mean.R"), fill = "white", position=dodge) +
                        my.graph.settings(angle) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(fill = fill.label) +
                        scale_fill_manual(values = brewer.pal(3,"Set1")[c(1, 2)]) +
                        coord_cartesian(ylim = c((
                                min(summary$lower) - 5 * mean(summary$se)
                        ), (
                                max(summary$upper) + 5 * mean(summary$se)
                        )))
                
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                print(summary)
                return(graph)
        }


# 
# 
# #2 x 2 Bar Graph
# my.grouped.barplot <-
#         function(dataset,
#                  x,
#                  y,
#                  group,
#                  xlab = x,
#                  ylab = y,
#                  fill.label = group,
#                  round = 2,
#                  angle = 0,
#                  ordered = F) {
#                 quo_x <- rlang::sym(x)
#                 quo_y <- rlang::sym(y)
#                 quo_group <- sym(group)
#                 summary <- dataset %>% my.grouped.summary(x, y, group)
#                 #print(summary)
#                 if(ordered == T){
#                         names(summary)[names(summary) == x] <- "x"
#                         names(summary)[names(summary) == group] <- "group"
#                         print(summary)
#                         summary1 <- summary %>% 
#                                 tibble() %>% 
#                                 arrange(mean)
#                         print(summary1)
#                         summary2 <- summary1 %>% 
#                                 mutate(x = factor(x, levels=x[group == "group"]))
#                         print(summary2)
#                         names(summary2)[names(summary2) == "x"] <- x
#                         names(summary2)[names(summary2) == "group"] <- group
#                         print(summary2)
#                         summary <- summary2
#                  }
#                 limits <- aes(ymax = max, ymin = min)
#                 dodge <- position_dodge(width = .9)
#                 graph <-
#                         ggplot(summary,
#                                aes_string(
#                                        x = x,
#                                        y = "mean",
#                                        fill = group,
#                                        group = group
#                                )) +
#                         geom_bar(stat = 'identity', position = dodge) +
#                         geom_errorbar(limits, position = dodge, width = .2) +
#                         #geom_label(aes_string(label = "mean.R"), fill = "white", position=dodge) +
#                         my.graph.settings(angle) +
#                         ylab(ylab) +
#                         xlab(xlab) +
#                         labs(fill = fill.label) +
#                         scale_fill_manual(values = brewer.pal(3,"Set1")[c(1, 2)]) +
#                         coord_cartesian(ylim = c((
#                                 min(summary$lower) - 5 * mean(summary$se)
#                         ), (
#                                 max(summary$upper) + 5 * mean(summary$se)
#                         )))
# 
#                 measurevar <- y
#                 groupvars  <- c(x, group)
#                 f <-
#                         paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
#                 lm <- anova(lm(f, data = dataset))
#                 print(lm)
#                 print(summary)
#                 return(graph)
#         }
# 

my.grouped.barplot.facet <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 fill.label = group,
                 round = 2,
                 angle = 0,
                 ordered = F) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% my.grouped.summary(x, y, group)
                if(ordered == T){
                        names(summary)[names(summary) == x] <- "x"
                        names(summary)[names(summary) == group] <- "group"
                        print(summary)
                        summary1 <- summary %>% 
                                tibble() %>% 
                                arrange(mean)
                        print(summary1)
                        summary2 <- summary1 %>% 
                                mutate(x = factor(x, levels=x[group == "group"]))
                        print(summary2)
                        names(summary2)[names(summary2) == "x"] <- x
                        names(summary2)[names(summary2) == "group"] <- group
                        print(summary2)
                        summary <- summary2
                }
                limits <- aes(ymax = max, ymin = min)
                dodge <- position_dodge(width = .9)
                graph <-
                        ggplot(summary,
                               aes_string(
                                       x = x,
                                       y = "mean",
                                       fill = group
                               )) +
                        geom_bar(stat = 'identity', position = dodge) +
                        geom_errorbar(limits, position = dodge, width = .2) +
                        my.graph.settings(angle) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(fill = fill.label) +
                        scale_fill_manual(values = brewer.pal(3,"Set1")[c(2, 1)]) +
                        coord_cartesian(ylim = c((
                                min(summary$lower) - 5 * mean(summary$se)
                        ), (
                                max(summary$upper) + 5 * mean(summary$se)
                        ))) +
                        facet_grid(reformulate(group))
                        
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                print(summary)
                return(graph)
        }




# Boxplots -----------------------------------------------
my.boxplot <-
        function(data,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .8,
                 fill = "#F0E442",
                 alpha = .8,
                 height = .1,
                 points = F,
                 ordered = F,
                 angle = 0,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                condensed <- my.summary(data, x, y)
                if(ordered == T){
                        condensed <- condensed %>% arrange(mean)
                        condensed[[x]] <- factor(condensed[[x]], levels = condensed[[x]])
                        data[[x]] <- factor(data[[x]], levels = condensed[[x]])
                }
                graph <-
                        ggplot(condensed, aes_string(x = x, 
                                                     y = "mean")) +
                        geom_boxplot(
                                aes_string(
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max"
                                ),
                                width = width,
                                stat = "identity",
                                fill = fill,
                                alpha = alpha
                        ) +
                        ylab(ylab) +
                        xlab(xlab) +
                        my.graph.settings(angle)
                if (points == "jitter") {
                        graph <- graph +
                                geom_jitter(
                                        data = data,
                                        aes_string(x = x, 
                                                   y = y),
                                        pch = 21,
                                        color = "black",
                                        fill = "gray88",
                                        position = position_jitter(width = width / 10, 
                                                                   height = width /10
                                        )
                                )
                        graph$layers <- rev(graph$layers)
                }
                else if (points == "count") {
                        graph <- graph +
                                geom_count (
                                        data = data,
                                        aes_string(x = x, 
                                                   y = y),
                                        pch = 21,
                                        color = "black",
                                        fill = "gray88"
                                )
                        graph$layers <- rev(graph$layers)
                }
                
                measurevar <- y
                predictor  <- x
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- anova(lm(f, data = data))
                #print(lm)
                return(graph)
        }


#2 x 2 Box Plot
my.grouped.boxplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 points = "none",
                 colors = blue.yellow,
                 angle = 0,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% my.grouped.summary(x, y, group)
                graph <- ggplot(summary, aes_string(x = x, y = "mean", fill = group)) +
                        geom_boxplot(
                                data = summary,
                                aes_string(
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max",
                                        width = .7
                                        
                                ),
                                fatten = 1,
                                stat = "identity"
                        ) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        my.graph.settings(angle) +
                        coord_cartesian(...)
                if(points == "jitter"){
                        graph <- graph +
                                geom_point(data = dataset,
                                           aes_string(x = x, y = y),
                                           position=position_jitterdodge(dodge.width = .7, jitter.width = width, jitter.height = height),
                                           alpha = .1)
                        graph$layers <- rev(graph$layers)
                        
                }
                if(points == "count"){
                        graph <- graph +
                                geom_count(data = dataset,
                                           aes_string(x = x, y = y, group = group),
                                           position=position_dodge(width = .7),
                                           pch = 21,
                                           color = "black",
                                           fill = "gray88",
                                           alpha = .3) +
                                guides(size = F)
                        graph$layers <- rev(graph$layers)
                        
                }
                if(summary[group] %>% unique() %>% nrow() == 2){
                        graph <- graph +
                                scale_fill_manual(values=colors) +
                                scale_color_manual(values=colors)
                }
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }

#2 x 2 x 2 Box Plot
my.2x2x2.boxplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 panels,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 colors = red.blue,
                 points = "none") {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                quo_panels <- sym(panels)
                condensed <-
                        dataset %>% group_by(!!quo_group, !!quo_x, !!quo_panels) %>%
                        summarise(
                                SE = sd(!!quo_y, na.rm = T) / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y)
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                graph <-
                        ggplot(condensed, aes_string(x = x, y = "mean")) +
                        geom_boxplot(
                                data = condensed,
                                aes_string(
                                        fill = group,
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max",
                                        width = .7
                                ),
                                stat = "identity",
                                alpha = .8
                        ) +
                        facet_grid(reformulate(panels)) +
                        scale_fill_manual(values = colors) +
                        scale_color_manual(values = colors) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        my.graph.settings(0)
                if (points == "jitter") {
                        graph <- graph +
                                geom_jitter(
                                        data = dataset,
                                        aes_string(
                                                x = x,
                                                y = y,
                                                fill=group
                                        ),
                                        position=position_jitterdodge(jitter.width = .3),
                                        color = "grey",
                                        alpha = .2
                                        )
                                
                        graph$layers <- rev(graph$layers)
                        
                }
                measurevar <- y
                groupvars  <- c(x, group, panels)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(list(lm, condensed))
                return(graph)
        }


# Violin ------------------------------------------------------------------


my.violin <- function(data, x, y, ...) {
        quo_x <- sym(x)
        quo_y <- sym(y)
        summary <- my.summary(data, x, y)
        graph <-
                ggplot(data = data, aes_string(
                        x = x,
                        y = y,
                        fill = x
                )) +
                scale_fill_viridis_d(option = "D") +
                geom_violin(
                        alpha = 0.4,
                        position = position_dodge(width = .75),
                        size = 1,
                        color = "black"
                ) +
                geom_jitter(
                        shape = 21,
                        size = 2,
                        color = "black",
                        alpha = 1,
                        width = .15,
                        height = .1
                ) +
                stat_summary(
                        fun.y = mean,
                        geom = "point",
                        size = 4,
                        color = "red",
                        show.legend = F
                ) +
                geom_errorbar(
                        data = summary,
                        aes_string(
                                x = x,
                                y = "mean",
                                ymax = "upper",
                                ymin = "lower"
                        ),
                        position = position_dodge(),
                        width = 0.1
                ) +
                guides(fill = F) +
                coord_cartesian(...) +
                my.graph.settings()
        measurevar <- y
        groupvars  <- x
        f <- paste(measurevar, groupvars, sep = " ~ ")
        anova <- anova(lm(f, data = data))
        p_value <- paste("p =", round(anova[[5]][1], 3))
        #graph <- graph + annotate("text", x = 2.5, y = -.2, label = p_value)
        print(anova)
        graph
}




my.grouped.violin <- function(data, variable) {
        quo_variable <- rlang::sym(variable)
        summary <- ApData %>% group_by(Condition) %>%
                summarise(
                        mean = mean(!!quo_variable, na.rm = T),
                        sd = sd(!!quo_variable, na.rm = T),
                        n = n()
                )
        summary$se <- summary$sd / sqrt(summary$n)
        summary$upper <-
                summary$mean + 1.96 * summary$se
        summary$lower <- summary$mean - 1.96 * summary$se
        
        graph <-
                ggplot(data = ApData,
                       aes_string(
                               x = "Condition",
                               y = variable,
                               fill = "Condition"
                       )) +
                scale_fill_viridis_d(option = "D") +
                geom_violin(
                        alpha = 0.4,
                        position = position_dodge(width = .75),
                        size = 1,
                        color = "black"
                ) +
                geom_jitter(
                        shape = 21,
                        size = 2,
                        color = "black",
                        alpha = 1,
                        width = .15,
                        height = .1
                ) +
                stat_summary(
                        fun.y = mean,
                        geom = "point",
                        size = 4,
                        color = "red",
                        show.legend = F
                ) +
                geom_errorbar(
                        data = summary,
                        aes_string(
                                x = "Condition",
                                y = "mean",
                                ymax = "upper",
                                ymin = "lower"
                        ),
                        position = position_dodge(),
                        width = 0.1
                ) +
                my.graph.settings()
        measurevar <- variable
        groupvars  <- "Condition"
        f <- paste(measurevar, groupvars, sep = " ~ ")
        anova <- anova(lm(f, data = ApData))
        p_value <- paste("p =", round(anova[[5]][1], 3))
        graph <-
                graph + annotate("text",
                                 x = 2.5,
                                 y = -.2,
                                 label = p_value)
        graph
}






# Line Graphs -------------------------------------------------------------
# Line Graph
my.linegraph <- function(dataset,
                         x,
                         y,
                         xlab = x,
                         ylab = y) {
        quo_x <- rlang::sym(x)
        quo_y <- rlang::sym(y)
        summary <- dataset %>% group_by(!!quo_x) %>%
                summarise(
                        mean = mean(!!quo_y, na.rm = T),
                        sd = sd(!!quo_y, na.rm = T),
                        n = n()
                )
        summary$se <- summary$sd / sqrt(summary$n)
        summary <- summary[complete.cases(summary), ]
        print(summary)
        print(quo_x)
        graph <- ggplot(summary, aes_string(x = x, y = "mean")) +
                geom_point(stat = 'identity', size = 3) +
                geom_line(lwd = 1) +
                my.graph.settings(0) +
                ylab(ylab) +
                xlab(xlab) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1))
        # measurevar <- y
        # groupvars  <- c(x)
        # f <- paste(measurevar, sep=" ~ ")
        # lm <- anova(lm(f, data=dataset))
        # print(lm)
        return(graph)
}

require(RColorBrewer)



# Grouped Line Graph
my.grouped.linegraph <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                mean = mean(!!quo_y, na.rm = T),
                                sd = sd(!!quo_y, na.rm = T),
                                n = n()
                        )
                summary <- summary[complete.cases(summary), ]
                print(summary)
                print(quo_x)
                graph <-
                        ggplot(summary,
                               aes_string(
                                       x = x,
                                       y = "mean",
                                       color = group,
                                       group = group
                               )) +
                        geom_point(stat = 'identity', size = 3) +
                        geom_line(lwd = 1) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        scale_fill_brewer(palette = "Set1") +
                        scale_color_brewer(palette = "Set1") +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1))
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }




# Scatterplots ------------------------------------------------------------
my.scatterplot <-
        function(data,
                 x,
                 y,
                 jittersize = 0,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 se = F,
                 show_coeff = F) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                graph <- ggplot(data = data, aes_string(x = x, y = y)) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2,
                                show.legend = FALSE,
                                fullrange = TRUE
                        ) +
                        geom_smooth(
                                method = "lm",
                                method.args = list(family = family),
                                se = se,
                                color = "#FC4E07",
                                fill = "#FC4E07"
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian()
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                if(show_coeff == TRUE){
                graph <-
                        graph + annotate(
                                "label",
                                x = mean(data[[x]], na.rm = T),
                                y = mean(data[[y]], na.rm = T),
                                label = round(lm$coefficients[8], 3)
                        )
                }
                print(lm)
                corr <- cor.test(data[[x]], data[[y]])
                print(corr)
                return(graph)
                
        }




my.grouped.scatterplot <-
        function(data,
                 x,
                 y,
                 group,
                 color.lab = group,
                 size = 2,
                 jittersize = .2,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 se = FALSE,
                 points = T,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = group,
                                fill = group
                        )) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = se,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        theme(legend.key = element_blank()) +
                        # guides(size = F,
                        #        fill = T) +
                        labs(color = color.lab) +
                        coord_cartesian(...)
                if (points == TRUE){
                        graph <- graph + geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = size
                        )
                        
                }
                
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }




my.grouped.binomial.scatterplot <-
        function(data,
                 x,
                 y,
                 group,
                 jittersize = .2,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = group
                        )) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2,
                                show.legend = FALSE
                        ) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = FALSE,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        coord_cartesian(...)
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }


# 2 x 2 Scatterplot
# Scatterplot plus 2-way regression line
my.2x2.scatterplot <-
        function(data,
                 x,
                 y,
                 group1,
                 group2,
                 jittersize = .2,
                 alpha = .2) {
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = interaction(group1, group2)
                        )) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2
                        ) +
                        geom_smooth(
                                method = "loess",
                                se = FALSE,
                                show.legend = FALSE,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        labs(y = y,
                             x = x,
                             color = "Status")
                lm <-
                        summary(lm(data[[y]] ~ data[[x]] * data[[group1]] * data[[group2]], data = data))
                output <- list("lm" = lm, "graph" = graph)
                return(output)
        }

my.binomial.scatterplot <- function(data, x, y, group) {
        graph <- ggplot(data = data, aes_string(
                x = x,
                y = y,
                color = group
        )) +
                geom_jitter(
                        height = .00,
                        width = .3,
                        alpha = 4 / 10,
                        size = count
                ) +
                scale_color_manual(values = c("#1675B5", "#b52616")) +
                geom_smooth(
                        method = "glm",
                        method.args = list(family = "binomial"),
                        se = FALSE,
                        fullrange = TRUE
                ) +
                theme(
                        panel.grid.major.y = element_line(color = "grey90"),
                        panel.grid.major.x = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_rect(fill = "transparent", colour = NA),
                        plot.background = element_rect(fill = "transparent", colour = NA),
                        legend.background = element_rect(fill = "transparent", colour = NA),
                        legend.key = element_rect(fill = "transparent", colour = NA)
                ) +
                theme(
                        axis.line.x = element_line(color = "black", size = .5),
                        axis.line.y = element_line(color = "black", size = .5)
                ) +
                theme(axis.title = element_text(face = "bold")) +
                theme(legend.title = element_text(face = "bold")) +
                labs(y = y,
                     x = x,
                     color = group)
        measurevar <- y
        groupvars  <- c(x, group)
        f <-
                paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
        lm <-
                summary(glm(f, family = binomial(link = logit), data = data))
        print(lm)
        return(graph)
}

# Count plots --------------------------------------------------------------
my.countplot <-
        function(data,
                 x,
                 y,
                 alpha = .2,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <- ggplot(data = data, aes_string(x = x, y = "Ry")) +
                        geom_count(show.legend = FALSE,
                                   color = "darkblue",
                                   alpha = .8) +
                        scale_color_manual(values = my.bright.colors) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = T,
                                fullrange = F,
                                color = "#FC4E07",
                                fill = "#FC4E07"
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(...) +
                        theme(axis.text = element_blank())
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }

my.grouped.countplot <-
        function(data,
                 x,
                 y,
                 group,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 alpha = .2,
                 legend = F,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = "Ry",
                                color = group,
                                fill = group
                        )) +
                        geom_count(show.legend = FALSE,  alpha = alpha) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = TRUE,
                                fullrange = TRUE,
                                show.legend = legend
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        coord_cartesian(...)
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }


my.overlap <- function(data, x, y) {
        table <- table(is.na(data[x]), is.na(data[y]))
        table
        
        
        
}



my.marginal.countplot <-
        function(data,
                 x,
                 y,
                 alpha = .2,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <- ggplot(data = data, aes_string(x = x, y = "Ry")) +
                        geom_count(show.legend = FALSE,
                                   color = "darkblue",
                                   alpha = .8) +
                        scale_color_manual(values = my.bright.colors) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = T,
                                fullrange = F,
                                color = "#FC4E07",
                                fill = "#FC4E07"
                        ) +
                        theme_light() +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(...) +
                        theme(axis.text = element_blank())
                pmain <- graph
                darkblue <- "darkblue"
                xdens <- axis_canvas(pmain, axis = "x") +
                        geom_density(
                                data = data,
                                aes_string(x = quo_x, fill = 3),
                                alpha = 0.7,
                                size = 0.2
                        )
                ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE) +
                        geom_density(
                                data = data,
                                aes_string(x = quo_y, fill = 3),
                                alpha = 0.7,
                                size = 0.2
                        ) +
                        coord_flip()
                p1 <-
                        insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
                p2 <-
                        insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
                p3 <- ggdraw(p2)
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(p3)
        }




# Histogram ---------------------------------------------------------------
my.histogram <-
        function(data,
                 variable,
                 bins = NULL,
                 percent = FALSE) {
                if (percent == FALSE) {
                        graph <-
                                ggplot(data, aes_string(x = variable)) + geom_histogram(bins = bins) +
                                theme_bw()
                        print(graph)
                }
                else {
                        ggplot(data, aes_string(x = variable)) +
                                geom_bar(aes(y = ..prop.., stat = "count")) +
                                geom_text(
                                        aes(
                                                label = scales::percent(..prop..),
                                                y = ..prop..
                                        ),
                                        stat = "count",
                                        vjust = -.5,
                                        size = 2
                                ) +
                                scale_y_continuous(labels = scales::percent) +
                                labs(y = "Proportion")
                }
        }



my.grouped.histogram <-
        function(data,
                 variable,
                 group,
                 bins = NULL,
                 percent = FALSE) {
                summary <- data %>% my.summary(group, variable)
                print(summary)
                if (percent == FALSE) {
                        graph <-
                                ggplot(data, aes_string(x = variable)) + 
                                geom_histogram(bins = bins) +
                                facet_wrap(reformulate(group)) + 
                                theme_bw()                }
                else {
                        graph <- ggplot(data, aes_string(x = variable,  group = group)) +
                                geom_bar(aes(y = ..prop.., stat = "count")) +
                                facet_wrap(reformulate(group)) +
                                # geom_text(
                                #         aes(
                                #                 label = scales::percent(..prop..),
                                #                 y = ..prop..
                                #         ),
                                #         stat = "count",
                                #         vjust = -.5,
                                #         size = 2
                                # ) +
                                scale_y_continuous(labels = scales::percent) +
                                labs(y = "Proportion")
                }
                graph <- graph +
                        geom_vline(data = summary,
                                   aes(xintercept = mean),
                              color = "black",
                              linetype = "dashed",
                              size = 1)
                graph
        }

# Create a residual variable
my.residual <- function(data, variable, ..., family = "gaussian") {
        predictors <- paste(..., sep = " + ")
        f <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(glm(f, family = family, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        drop <-
                c(".fitted",
                  ".se.fit",
                  ".hat",
                  ".sigma",
                  ".cooksd",
                  ".std.resid")
        data <- data %>% select(-one_of(drop))
        return(data)
}

my.multilevel.residual <- function(data, variable, subjectID, ...) {
        subject <- paste0("(1|", subjectID, ")")
        predictors <- paste(..., subject, sep = " + ")
        f <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(lmer(f, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        drop <-
                c(".fitted",
                  ".se.fit",
                  ".hat",
                  ".sigma",
                  ".cooksd",
                  ".std.resid")
        data <- data %>% select(-one_of(drop))
        return(data)
}




# Check Crosstabs (NA) ----------------------------------------------------

my.missing.data <- function(data, string) {
        try <- strsplit(string, "\\+|~")
        try <- try[[1]]
        try <- gsub("\\s+", "" , try)
        matrix <- select(data, try)
        mice:::md.pattern(matrix)
}


# my.missing.data.model <- function(model) {
#         model.frame <- model.frame(model)
#         names <- names(model.frame)
#         df <- df %>% select(names)
#         mice:::md.pattern(df)
# }

my.missing.data.model <- function(model) {
        mice:::md.pattern(model.frame(model))
}

## EXAMPLE my.crosstab(ImmediateFollowup, "TE ~ MoneyFree + EducationC + AgeC + IncomeC + GenderFemale + GenderMale")


# Make class lmer ---------------------------------------------------------

my.make.class.lmer <- function(x) {
        class(x) <- "lmerMod"
}


my.split <- function(x) {
        median <- (max(x, na.rm = T) - min(x, na.rm = T)) / 2
        newvar <- ifelse(x < median, 0, ifelse(x > median, 1, NA))
        return(newvar)
}




# Multiple Imputation -----------------------------------------------------
my.select <- function(string) {
        # Get each variable name individually
        try <- strsplit(string, "\\+|~|\\(1\\||\\)\\|\\)|, data = ")
        try <- try[[1]]
        try <- gsub("\\s+", "" , try)
        try <- gsub("\\)", "" , try)
        try <- try[try != ""]
        data <- tail(try, 1)
        variables <- head(try, c(length(try) - 1))
        data.frame <- eval(sym(data))
        data.frame <- data.frame %>% select(variables)
        data.frame
}



 my.imputation <- function(model, data.frame, use = NA) {
        require(mice) # You will need to install this package if you don't have it already
        names <- names(model.frame(model))
        data.frame <- data.frame %>% select(names)
        
        init <-
                mice(data.frame, maxit = 0) # Initialize the imputation
        meth <-  init$method
        predM <-  init$predictorMatrix
        
        # This if/then statement allows you to specify with variables you want to impute. Default is all;
        # But specific vars can be input like so: use = c("var1", "var2")
        if (is.na(use)) {
                meth <- meth
        } else{
                meth[!names(meth) %in% c(use)] <- ""
                meth[use] <-  "pmm"
        }
        
        imputed <-
                mice(
                        data.frame,
                        method = meth,
                        predictorMatrix = predM,
                        m = 20
                        ) # Perform the multiple imputation
        
        formula <- paste0(as.character(formula(model))[2], as.character(formula(model))[1], as.character(formula(model))[3])
        # Now run the regression equation on the multiply imputed data
        modelFit1 <- with(imputed, lm(formula = eval(parse(text = formula))))

        # Get the summary of the regression output and print it.
        summary(pool(modelFit1))

}

 citation("mice")




# Countplot Plus Boxplot ------------------------------------------------------------


my.boxplot.countplot <-
        function(data,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .8,
                 fill = "red",
                 alpha = .8,
                 height = .1,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data.count <- data %>%
                        group_by(!!quo_x,!!quo_y) %>%
                        summarise(n = n()) %>%
                        na.omit() %>%
                        mutate(freq = n / sum(n))
                #return(print(data.count, n = 100))
                size_range <- c(min(data.count$freq), max(data.count$freq))
                condensed <- my.summary(data, x, y)
                graph <-
                        ggplot(condensed, aes_string(
                                x = x,
                                y = "mean",
                                fill = x
                        )) +
                        geom_boxplot(
                                aes_string(
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max"
                                ),
                                width = width,
                                stat = "identity",
                                alpha = alpha
                        ) +
                        geom_point(
                                data = data.count,
                                aes_string(
                                        x = x,
                                        y = y,
                                        size = "freq"
                                ),
                                pch = 21,
                                color = "black",
                                fill = "gray88",
                                alpha = .3
                        ) +
                        scale_size_continuous(
                                labels = scales::percent_format(accuracy = 1),
                                name = "Proportion",
                                limits = size_range,
                                range = c(0, 10)
                        ) +
                        scale_fill_viridis_d(option = "D") +
                        ylab(ylab) +
                        xlab(xlab) +
                        guides(fill = F) +
                        my.graph.settings(0) +
                        coord_cartesian(...)
                return(graph)
        }


 

# Print Regression Tables -------------------------------------------------

 
print_lm <-
         function(themodel, 
                  predictor,
                  dv,
                  caption,
                  timepoint = NULL
         ) {
                 if (is.null(caption)){
                         caption <- paste0("Predictor: ", predictor, "; Dependent Variable: ", dv)
                         if (!is.null(timepoint)){
                                 caption <- paste0(caption, "; Timepoint: ", timepoint)
                         }
                 } else {
                         caption <- caption
                 }
                 
                 df <- themodel %>% summary %>% coefficients %>% tail(-1)
                 confint <- confint(themodel) %>% tail(-1)
                 #std.beta <- std_beta(themodel)[,1:2]
                 order <- order(row.names(df))
                 df <- merge(df, confint, by = "row.names") %>%
                         #merge(std.beta, by.x = "Row.names", by.y = "term")%>%
                         arrange(order)
                 df$df <- (themodel$df.residual)
                 
                 
                 dv <- colnames(model.frame(themodel))[1]
                 
                 df <- df %>%
                         rename("p" = "Pr(>|t|)")
                 
                 df$pval = format(round(df$p, digits = 3), nsmall = 3) # round p-values into new variable
                 df$pstring = as.character(df$pval) # convert this variable intro new string variable
                 df$pmaterial = df$pstring
                 
                 
                 df$pstring[df$p < 0.1 &
                                    df$p >= 0.05] <-
                         paste(df$pmaterial[df$p < 0.1 &
                                                    df$p >= 0.05], "(ref:cross)", sep = "")
                 df$pstring[df$p < 0.05 &
                                    df$p >= 0.01] <-
                         paste(df$pmaterial[df$p < 0.05 &
                                                    df$p >= 0.01], "(ref:ast)", sep = "")
                 df$pstring[df$p < 0.01 &
                                    df$p >= 0.001] <-
                         paste(df$pmaterial[df$p < 0.01 &
                                                    df$p >= 0.001], "(ref:ast)", "(ref:ast)", sep = "")
                 df$pstring[df$p < .001] <-
                         paste("< ",
                               "0.001",
                               "(ref:ast)",
                               "(ref:ast)",
                               "(ref:ast)",
                               sep = "")
                 
                 df$pstring <-
                         gsub("0\\.", "\\.", df$pstring)  # add for removing the zero in front of the p values
                 
                 df <- df %>% select(-c(p, pval, pmaterial))
                 
                 
                 df$rhs <- df %>% rownames()
                 rownames(df) <- c()
                 df <- df %>% rename(
                         "b" = "Estimate"
                         ,
                         "SE" = "Std. Error"
                         ,
                         "df" = "df"
                         ,
                         "t" = "t value"
                         ,
                         "(ref:cilower)" = "2.5 %"
                         ,
                         "(ref:ciupper)" = "97.5 %"
                         ,
                         "predictor" = "Row.names"
                         ,
                         "p" = "pstring"
                         #, "b" = "std.estimate"
                 )
                 
                 df <-
                         df %>% select(predictor,
                                       b,
                                       SE,
                                       "(ref:cilower)",
                                       "(ref:ciupper)",
                                       t,
                                       df,
                                       p)
                 
                 return(
                         apa_table(
                                 df,
                                 align = c("l", "r", "r", "r", "r", "r", "r", "S[table-format = <0.3]","r"),
                                 caption = caption,
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                                                        (ref:ast)(ref:ast)(ref:italp) < .01, 
                                                                        (ref:ast)(ref:italp) < .05, 
                                                                        (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                         )
                 )
                 
         }
 
 
 
 
 
 print_lmer <- 
         function(themodel, 
                  predictor,
                  dv,
                  caption
         ) {
                 df <- themodel %>% summary %>% coefficients %>% tail(-1)
                 confint <- confint(themodel) %>% tail(-3)
                 #std.beta <- std_beta(themodel)[,1:2]
                 order <- order(row.names(df))
                 df <- merge(df, confint, by = "row.names") %>%
                         #merge(std.beta, by.x = "Row.names", by.y = "term")%>%
                         arrange(order)
                 dv <- colnames(model.frame(themodel))[1]
                 
                 df <- df %>%
                         rename("p" = "Pr(>|t|)")
                 
                 df$pval = format(round(df$p, digits = 3), nsmall = 3) # round p-values into new variable
                 df$pstring = as.character(df$pval) # convert this variable intro new string variable
                 df$pmaterial = df$pstring
                 df$pstring[df$p < 0.1 &
                                    df$p >= 0.05] <-
                         paste(df$pmaterial[df$p < 0.1 &
                                                    df$p >= 0.05], "(ref:cross)", sep = "")
                 df$pstring[df$p < 0.05 &
                                    df$p >= 0.01] <-
                         paste(df$pmaterial[df$p < 0.05 &
                                                    df$p >= 0.01], "(ref:ast)", sep = "")
                 df$pstring[df$p < 0.01 &
                                    df$p >= 0.001] <-
                         paste(df$pmaterial[df$p < 0.01 &
                                                    df$p >= 0.001], "(ref:ast)", "(ref:ast)", sep = "")
                 df$pstring[df$p < .001] <-
                         paste("< ",
                               "0.001",
                               "(ref:ast)",
                               "(ref:ast)",
                               "(ref:ast)",
                               sep = "")
                 
                 df$pstring <-
                         gsub("0\\.", "\\.", df$pstring)  # add for removing the zero in front of the p values
                 
                 df <- df %>% select(-c(p, pval, pmaterial))
                 df$rhs <- df$Row.names
                 rownames(df) <- c()
                 df <- df %>% rename(
                         "b" = "Estimate"
                         ,
                         "SE" = "Std. Error"
                         ,
                         "df" = "df"
                         ,
                         "t" = "t value"
                         ,
                         "(ref:cilower)" = "2.5 %"
                         ,
                         "(ref:ciupper)" = "97.5 %"
                         ,
                         "Predictor" = "Row.names"
                         ,
                         "p" = "pstring"
                         #, "b" = "std.estimate"
                 )
                 df <-  df %>% select(Predictor,
                                       b,
                                       SE,
                                       "(ref:cilower)",
                                       "(ref:ciupper)",
                                       t,
                                       df,
                                       p)
                 return(
                         papaja::apa_table(
                                 df,
                                 align = c("l", "r", "r", "r", "r", "r", "r", "S[table-format = <0.3]"),
                                 caption = "caption",
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                         (ref:ast)(ref:ast)(ref:italp) < .01, 
                                         (ref:ast)(ref:italp) < .05, 
                                         (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                         )
                         )
         }


 print_lavaan <-
         function(themodel,
                  thecaption = "Enter a caption.",
                  thenotes = "",
                  namedv = "",
                  exclude = c(0)) {
                 aa <- standardizedsolution(themodel) %>% data.frame()
                 
                 aa$pstring = format(round(aa$p, digits = 3), nsmall = 3) %>% as.character()
                 aa <-
                         aa %>% mutate(
                                 pstring = case_when(
                                         between(pvalue, .05, .1) ~ paste(pstring, "(ref:cross)", sep = ""),
                                         between(pvalue, .01, .05) ~ paste(pstring, "(ref:ast)", sep =
                                                                                   ""),
                                         between(pvalue, .001, .01) ~ paste(pstring, "(ref:ast)", "(ref:ast)", sep =
                                                                                    ""),
                                         pvalue < .001 ~ paste(
                                                 "< ",
                                                 "0.001",
                                                 "(ref:ast)",
                                                 "(ref:ast)",
                                                 "(ref:ast)",
                                                 sep = ""
                                         ),
                                         pvalue >= .1 ~ pstring
                                 )
                         )
                 aa$pstring[is.na(aa$z)] <- NA
                 aa <-
                         aa[, c("lhs",
                                "op",
                                "rhs",
                                "est.std",
                                "se",
                                "ci.lower",
                                "ci.upper",
                                "z",
                                "pstring")]
                 
                 aa$pstring <-
                         gsub("0\\.", "\\.", aa$pstring)  # add for removing the zero in front of the p values
                 
                 names(aa)[names(aa) == "est.std"] <- "B"
                 names(aa)[names(aa) == "lhs"] <- "Criterion"
                 names(aa)[names(aa) == "ci.lower"] <- "(ref:cilower)"
                 names(aa)[names(aa) == "ci.upper"] <- "(ref:ciupper)"
                 names(aa)[names(aa) == "rhs"] <- "Predictor"
                 names(aa)[names(aa) == "pstring"] <- "p"
                 names(aa)[names(aa) == "std.all"] <- "(ref:beta)"
                 names(aa)[names(aa) == "se"] <- "SE"
                 
                 aa = aa[(aa$op == "~" | aa$op == ":="), ]
                 
                 aa$op[aa$op == "~"] = "\U2190"
                 aa$Predictor[aa$op == ":="] = ""
                 aa$op[aa$op == ":="] = "on"
                 
                 names(aa)[names(aa) == "op"] <- ""
                 aa$Predictor[aa$Predictor == ""] <- "Moral Expansion"
                 
                 #aa <- data.frame(aa)
                 return(
                         apa_table(
                                 aa,
                                 align = c(
                                         "c",
                                         "l",
                                         "l",
                                         "r",
                                         "r",
                                         "r",
                                         "r",
                                         "r",
                                         "S[table-format = <0.3]"
                                 ),
                                 caption = thecaption,
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                        (ref:ast)(ref:ast)(ref:italp) < .01, 
                                        (ref:ast)(ref:italp) < .05, (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                                 #col_spanners = list(c(4,5))
                                 #format.args = list(margin = 2)
                         )
                 )
                 
         }
 
 

# Fuzzy Merge -------------------------------------------------------------
 
# Take two datasets with imperfectly matching 
 
# require(devtools)
# devtools::install_version("RecordLinkage",version="0.4-1")
#  
my.fuzzy.merge <- function(dataset1, dataset2, var1, var2){
        library("RecordLinkage")
        ClosestMatch = function(string, stringVector){
                distance = levenshteinSim(string, stringVector);
                stringVector[distance == max(distance)]
        }
        
        for(i in 1:length(dataset2[[var2]])) {
                Matches <- ClosestMatch(dataset2[[var2]][i], levels(dataset1[[var1]]))
         }
        merge(dataset1, dataset2, by.x = var1, by.y = "name")
}
 

# Machine Learning Functions ----------------------------------------------

my.compare.proportions <- function(data, word){
        require(effectsize)
        table1 <- table(str_detect(data[["body"]], word), data[["approval_string"]])
        table2 <- prop.table(table(str_detect(data[["body"]], word), data[["approval_string"]]), 1)*100 
        # If it contains daughter, then 44% approve, versus not, 70%
        print(chisq.test(table1))
        print(cramers_v(table1))
        return(list(table1, table2))
}

 
my.find.with.word <- function(data, word){
        head <- head(data[["body"]][str_detect(data[["body"]], word)], 10)
        return(head)
}

my.find.with.word <- function(data, word){
        head <- head(data[["body"]][str_detect(data[["body"]], word)], 10)
        return(head)
}



# Factors -----------------------------------------------------------------

# This is specifically for when you have two
# Data frames, one levels one labels
# And you want to order the labels according to the levels

match_creator <- function(var_name,
                          data_levels = closing_gate_levels,
                          data_labels = closing_gate_labels)
{
        merged <- cbind(data_levels %>% select(var1 = !! sym(var_name)),
                        data_labels %>% select(var2 = !! sym(var_name)))
        
        merged[] <- lapply(merged[], function(x) fct_inorder(as.character(x)))
        merged <- merged %>% mutate(var3 = factor(var2,
                                                  labels = levels(merged$var2)[order(levels(merged$var1))]))
        return(merged$var3)
}

 

# Plot Mediation Functions ---------------------------------------------------
plot.mediation <- function(data, x, y, controls, ...){
        Adjusted <- my.multilevel.residual(data, variable = y, controls)
        y.resid <- paste(y, ".resid", sep = "")
        return(my.countplot(Adjusted, x, y.resid, ...))
        
}



my.multilevel.residual <- function(data, variable, controls) {
        subject <- paste0("(1|", "Survey", ")")
        predictors <- paste(controls, subject, sep = " + ")
        f <- paste(variable, predictors, sep=" ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- broom.mixed::augment(lmer(f, data=data), data)
        data <- data %>% rename_(.dots=setNames(list(var), new))
        drop <- c(".fitted", ".se.fit", ".hat", ".sigma", ".cooksd", ".std.resid")
        data <- data %>% select(-one_of(drop))
        return(data)
}

